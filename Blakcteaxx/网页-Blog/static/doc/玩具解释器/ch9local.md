---
title: 1. 局部变量
Author: Blackteaxx
Section: 玩具解释器
Description: 好吧，还没想好嘞
---


# Local Variables

```
program        → declaration* EOF ;

declaration    → varDecl
               | statement ;

varDecl        → "var" IDENTIFIER ( "=" expression )? ";" ;

statement      → exprStmt
               | printStmt
               | block ;

block          → "{" declaration* "}" ;
```

## 递归嵌套解析Token

没有代码会在运行时创建局部变量。想想虚拟机现在处于什么状态。它已经执行了变量初始化表达式的代码（如果用户省略了初始化，则是隐式的nil），并且该值作为唯一保留的临时变量位于栈顶。我们还知道，新的局部变量会被分配到栈顶……这个值已经在那里了。因此，没有什么可做的。临时变量直接成为局部变量。没有比这更有效的方法了。

解决问题：同一作用域下面的声明相同局部变量是不允许的

## 当一个代码块结束时，我们需要让其中的变量安息。

在运行时，我们使用栈中槽索引来加载和存储局部变量，
因此编译器在解析变量之后需要计算索引。每当一个变量被声明，
我们就将它追加到编译器的局部变量数组中。这意味着第一个局部变量在索引0的位置，
下一个在索引1的位置，以此类推。
换句话说，编译器中的局部变量数组的布局与虚拟机堆栈在运行时的布局完全相同。
变量在局部变量数组中的索引与其在栈中的槽位相同。多么方便啊！

vm.stack 存储值，根据常量值索引存储，局部变量数组的布局与虚拟机堆栈在运行时的布局完全相同
为什么相同呢？因为变量定义和赋值的时候都不会有虚拟机堆栈保留的存在（被pop掉了），因此如果开始有局部变量，那么局部变量的索引从0开始增加。
天才的想法